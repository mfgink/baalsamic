<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Baalsamic V10.4</title>

    <style>
        /* BASE */
        body { background: #0d0d0d; color: #ccc; font-family: monospace; padding: 0; margin: 0; height: 100vh; width: 100vw; overflow: hidden; }
        h1 { color: #ff0055; letter-spacing: 2px; text-transform: uppercase; margin: 20px 0; font-size: 1.5em; text-align: center; }
        
        /* LAYOUT UTILS */
        .container { max-width: 600px; margin: 0 auto; width: 100%; padding: 20px; box-sizing: border-box;}
        
        /* INGEST SCREEN (Visible by default) */
        #screen-ingest { 
            display: flex; 
            flex-direction: column; 
            height: 100%; 
            overflow-y: auto; 
        }

        /* CONFIG STYLES */
        .config-panel { background: #1a1a1a; padding: 15px; border: 1px solid #333; border-radius: 8px; margin-bottom: 20px; text-align: left; }
        .config-label { color: #ff0055; font-weight: bold; display: block; margin-bottom: 8px; font-size: 0.8em; text-transform: uppercase; }
        .radio-group { display: flex; gap: 10px; margin-bottom: 15px; }
        .radio-option { flex: 1; position: relative; }
        .radio-option input { opacity: 0; position: absolute; width: 100%; height: 100%; cursor: pointer; }
        .radio-tile { display: flex; align-items: center; justify-content: center; background: #222; border: 1px solid #444; padding: 12px; border-radius: 4px; transition: 0.2s; }
        .radio-option input:checked + .radio-tile { background: #ff0055; color: white; border-color: #ff0055; }
        .upload-input { padding: 15px; background: #222; border: 1px solid #333; color: #eee; width: 100%; box-sizing: border-box; border-radius: 4px; margin-bottom: 20px; }
        .btn-action { width: 100%; background: #00ffcc; color: black; border: none; padding: 15px; font-size: 1.2em; font-weight: bold; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; border-radius: 4px; }
        .btn-secondary { background: #333; color: #ccc; border: 1px solid #555; padding: 8px 15px; cursor: pointer; border-radius: 4px; font-size: 0.9em; white-space: nowrap;}

        /* TIME TRAVEL SCREEN (Hidden by default) */
        #screen-time-travel { 
            display: none; 
            flex-direction: column; 
            height: 100vh; 
            width: 100vw;
            background: #000;
        }

        /* 1. HEADER (5% Height) */
        .tuner-header {
            height: 5vh;
            max-height: 80px;
            min-height: 50px;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            background: #0d0d0d;
            border-bottom: 1px solid #333;
            z-index: 10;
        }
        .tuner-header h2 { margin: 0; color: #ff0055; font-size: 1.2em; letter-spacing: 1px; }

        /* 2. LIGHTBOX (Fills Remaining Space) */
        .lightbox-wrapper { 
            flex-grow: 1; 
            margin: 10px 0; 
            position: relative; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            overflow: hidden;
            width: 100%;
            background: #000;
        }
        
        .stage-container {
            position: relative;
            display: inline-block; /* Wraps tight around image */
        }

        #main_canvas {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            display: block;
            pointer-events: none; /* Pass clicks to Lens */
        }

        /* THE LENS (Red Box) */
        #crop-lens {
            position: absolute;
            top: 0; left: 0;
            height: 100%; 
            border: 2px solid #ff0055;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.85);
            cursor: grab;
            box-sizing: border-box;
            touch-action: none;
        }
        #crop-lens:active { cursor: grabbing; border-color: #fff; }

        /* 3. CONTROLS (25% Height) */
        .editor-controls {
            height: 25vh;
            max-height: 300px;
            min-height: 200px;
            flex-shrink: 0;
            background: #111;
            padding: 15px;
            border-top: 1px solid #333;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            box-sizing: border-box;
        }

        .control-row { display: flex; gap: 10px; margin-bottom: 10px; align-items: center; }
        .control-row label { color: #00ffcc; font-size: 0.8em; width: 50px; flex-shrink: 0; }
        input[type=range] { flex: 1; accent-color: #00ffcc; cursor: pointer; }
        
        .ratio-mini-group { display: flex; gap: 5px; flex: 1; }
        .ratio-btn { flex: 1; background: #222; border: 1px solid #444; color: #888; padding: 10px 5px; font-size: 0.75em; cursor: pointer; border-radius: 4px; }
        .ratio-btn.active { background: #ff0055; color: white; border-color: #ff0055; }

        /* LOADING OVERLAY */
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.92); z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center; color:#ff0055; backdrop-filter: blur(5px); }
        .loader { border: 4px solid #333; border-top: 4px solid #ff0055; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #overlay-text { font-family: monospace; font-size: 1.2em; color: #00ffcc; }
        
        video { display: none; }
    </style>
</head>
<body>

    <div id="overlay">
        <div class="loader"></div>
        <div id="overlay-text">BOOTING SYSTEM...</div>
    </div>

    <div id="screen-ingest" class="container">
        <h1>BAALSAMIC V10.4</h1>
        
        <div class="config-panel">
            <span class="config-label">Sampling Rate (FPS)</span>
            <div class="radio-group">
                <div class="radio-option"><input type="radio" name="fps" value="15" checked><div class="radio-tile"><span>15</span></div></div>
                <div class="radio-option"><input type="radio" name="fps" value="30"><div class="radio-tile"><span>30</span></div></div>
                <div class="radio-option"><input type="radio" name="fps" value="60"><div class="radio-tile"><span>60</span></div></div>
            </div>

            <span class="config-label">Resolution</span>
            <div class="radio-group">
                <div class="radio-option"><input type="radio" name="res" value="720" checked><div class="radio-tile"><span>SD</span></div></div>
                <div class="radio-option"><input type="radio" name="res" value="1080"><div class="radio-tile"><span>HD</span></div></div>
                <div class="radio-option"><input type="radio" name="res" value="0"><div class="radio-tile"><span>4K</span></div></div>
            </div>
        </div>

        <input type="file" id="upload" accept="video/*" class="upload-input">
        <button class="btn-action" id="btn_stitch">GET STITCHES</button>
    </div>

    <div id="screen-time-travel">
        <div class="tuner-header">
            <h2>FINE TUNE</h2>
            <button class="btn-secondary" id="close_tuner">CLOSE</button>
        </div>
        
        <div class="lightbox-wrapper">
            <div class="stage-container" id="stage_container">
                <canvas id="main_canvas"></canvas>
                <div id="crop-lens"></div>
            </div>
        </div>

        <div class="editor-controls">
            <div class="control-row">
                <label>CROP</label>
                <div class="ratio-mini-group">
                    <button class="ratio-btn" onclick="setRatio('max')">FULL</button>
                    <button class="ratio-btn active" onclick="setRatio('1:1')">1:1</button>
                    <button class="ratio-btn" onclick="setRatio('16:9')">16:9</button>
                    <button class="ratio-btn" onclick="setRatio('9:16')">9:16</button>
                </div>
            </div>

            <div class="control-row" id="row_pos">
                <label>POS</label>
                <input type="range" id="input_pos" min="0" max="100" value="50" oninput="updateLensPositionFromSlider()">
            </div>

            <div class="control-row">
                <label>WIDTH</label>
                <input type="range" id="input_width" min="1" max="200" value="12" onchange="triggerUpdate()">
            </div>
            <div class="control-row">
                <label>JITTER</label>
                <input type="range" id="input_jitter" min="0" max="50" value="5" onchange="triggerUpdate()">
            </div>

            <button class="btn-action" id="btn_render_final" style="margin-top:5px;">RENDER VIEW</button>
        </div>
    </div>

    <video id="hidden_video" muted playsinline></video>
    <canvas id="hidden_canvas"></canvas>

    <script>
    let currentRatio = '1:1';

    function setRatio(r) {
        currentRatio = r;
        document.querySelectorAll('.ratio-btn').forEach(btn => {
            btn.classList.remove('active');
            if(btn.innerText.toLowerCase() === r.toLowerCase() || 
               (r === 'max' && btn.innerText === 'FULL')) {
                btn.classList.add('active');
            }
        });
        
        const posRow = document.getElementById('row_pos');
        if (r === 'max') {
            posRow.style.opacity = '0.3';
            posRow.style.pointerEvents = 'none';
        } else {
            posRow.style.opacity = '1';
            posRow.style.pointerEvents = 'auto';
        }
        
        updateLensDimensions();
    }

    function updateLensDimensions() {
        const canvas = document.getElementById('main_canvas');
        const lens = document.getElementById('crop-lens');
        
        if (currentRatio === 'max') {
            lens.style.display = 'none';
            return;
        }
        lens.style.display = 'block';

        const visH = canvas.clientHeight;
        const visW = canvas.clientWidth;
        
        let targetW = visW;
        
        if (currentRatio === '1:1') targetW = visH; 
        
        // 16:9 is Wide (1.77), 9:16 is Tall (0.56)
        if (currentRatio === '16:9') targetW = visH * (16/9); 
        if (currentRatio === '9:16') targetW = visH * (9/16);

        if (targetW > visW) targetW = visW;

        lens.style.width = targetW + "px";
        lens.style.height = visH + "px";
        lens.style.top = canvas.offsetTop + "px";
        
        // Reset position to center if range changes
        const range = visW - targetW;
        const left = range / 2;
        lens.style.left = (canvas.offsetLeft + left) + "px";
        
        // Sync slider
        if(range > 0) {
            document.getElementById('input_pos').value = 50;
        }
    }

    function updateLensPositionFromSlider() {
        if (currentRatio === 'max') return;
        const canvas = document.getElementById('main_canvas');
        const lens = document.getElementById('crop-lens');
        const slider = document.getElementById('input_pos');
        
        const cw = canvas.clientWidth;
        const lw = parseFloat(lens.style.width);
        
        const range = cw - lw;
        const offset = (slider.value / 100) * range;
        
        lens.style.left = (canvas.offsetLeft + offset) + "px";
    }

    // DRAG LOGIC (Touch + Mouse)
    const lens = document.getElementById('crop-lens');
    let isDragging = false;
    let startX = 0;
    let startLeft = 0;

    function startDrag(e) {
        if(currentRatio === 'max') return;
        isDragging = true;
        startX = (e.touches ? e.touches[0].clientX : e.clientX);
        startLeft = parseFloat(lens.style.left) || 0;
        lens.style.cursor = 'grabbing';
    }

    function doDrag(e) {
        if(!isDragging) return;
        e.preventDefault();
        const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
        const delta = clientX - startX;
        const canvas = document.getElementById('main_canvas');
        
        const minLeft = canvas.offsetLeft;
        const maxLeft = minLeft + (canvas.clientWidth - parseFloat(lens.style.width));
        
        let newLeft = startLeft + delta;
        if(newLeft < minLeft) newLeft = minLeft;
        if(newLeft > maxLeft) newLeft = maxLeft;
        
        lens.style.left = newLeft + "px";
        
        // Sync slider
        const range = maxLeft - minLeft;
        if(range > 0) {
            document.getElementById('input_pos').value = ((newLeft - minLeft) / range) * 100;
        }
    }

    function stopDrag() {
        isDragging = false;
        lens.style.cursor = 'grab';
    }

    lens.addEventListener('mousedown', startDrag);
    lens.addEventListener('touchstart', startDrag);
    window.addEventListener('mousemove', doDrag);
    window.addEventListener('touchmove', doDrag, {passive: false});
    window.addEventListener('mouseup', stopDrag);
    window.addEventListener('touchend', stopDrag);


    function resetApp() {
        document.getElementById('screen-time-travel').style.display = 'none';
        document.getElementById('screen-ingest').style.display = 'flex';
    }

    function triggerUpdate() {
        window.call_py("await update_preview()");
    }

    window.addEventListener('resize', () => {
        setTimeout(updateLensDimensions, 100);
    });

    const PYODIDE_BASE = "https://cdn.jsdelivr.net/pyodide/v0.23.2/full/";
    
    function setLoading(msg, show=true) {
        const ov = document.getElementById("overlay");
        ov.style.display = show ? "flex" : "none";
        document.getElementById("overlay-text").innerText = msg;
    }

    (function(){
        const s = document.createElement("script");
        s.src = PYODIDE_BASE + "pyodide.js";
        s.onload = async () => {
            try {
                window.pyodide = await loadPyodide({indexURL: PYODIDE_BASE});
                window.call_py = async function(expr){ return await pyodide.runPythonAsync(expr); };
                await initializePython();
            } catch(e){ setLoading("INIT ERROR: " + e); }
        };
        document.head.appendChild(s);
    })();

    async function initializePython(){
        const code = document.getElementById("inline_python").textContent;
        await pyodide.runPythonAsync(code);
        
        document.getElementById("btn_stitch").onclick = async () => {
            setLoading("LOADING VIDEO...");
            await pyodide.runPythonAsync(`await ingest_video()`);
        };
        
        document.getElementById("btn_render_final").onclick = async () => {
            setLoading("RENDERING FINAL...");
            
            const canvas = document.getElementById("main_canvas");
            const lens = document.getElementById("crop-lens");
            
            const scale = canvas.width / canvas.clientWidth; 
            
            let sx = 0, sw = canvas.width;
            
            if (currentRatio !== 'max') {
                const canvasLeft = canvas.offsetLeft;
                const lensLeft = parseFloat(lens.style.left || 0);
                const relativeLeft = lensLeft - canvasLeft;
                
                sx = relativeLeft * scale;
                sw = parseFloat(lens.style.width) * scale;
                
                if(sx < 0) sx = 0;
                if(sx + sw > canvas.width) sw = canvas.width - sx;
            }
            
            const temp = document.createElement('canvas');
            temp.width = sw;
            temp.height = canvas.height;
            temp.getContext('2d').drawImage(canvas, sx, 0, sw, canvas.height, 0, 0, sw, canvas.height);
            
            const link = document.createElement('a');
            link.download = 'baalsamic_v10_4.png';
            link.href = temp.toDataURL();
            link.click();
            setLoading("", false);
        };

        setLoading("", false);
    }
    </script>

    <script type="text/python" id="inline_python">
from js import document, console, localStorage, JSON, window, setTimeout
import asyncio, random, math

current_seed = 0

async def ingest_video(*args):
    upload = document.getElementById("upload")
    if not upload.files.length:
        window.alert("Select a video first.")
        document.getElementById("overlay").style.display = "none"
        return
    
    file = upload.files.item(0)
    url = window.URL.createObjectURL(file)
    video = document.getElementById("hidden_video")
    video.src = url

    while not video.duration or math.isnan(video.duration):
        await asyncio.sleep(0.1)
    
    # --- AUTO-FIT LOGIC ---
    fps = int(document.querySelector('input[name="fps"]:checked').value)
    duration = video.duration
    total_frames = max(1, int(duration * fps))
    
    target_w = video.videoHeight * 0.75
    auto_slit = int(target_w / total_frames)
    auto_slit = max(1, min(200, auto_slit))
    
    document.getElementById("input_width").value = auto_slit
    document.getElementById("input_jitter").value = 5
    
    # Transition
    document.getElementById("screen-ingest").style.display = "none"
    document.getElementById("screen-time-travel").style.display = "flex"
    
    global current_seed
    current_seed = random.randint(100, 999)
    await update_preview()
    
    window.setRatio('1:1') 
    document.getElementById("overlay").style.display = "none"

async def update_preview(*args):
    width = int(document.getElementById("input_width").value)
    jitter = int(document.getElementById("input_jitter").value)
    fps = int(document.querySelector('input[name="fps"]:checked').value)
    res = int(document.querySelector('input[name="res"]:checked').value)
    
    video = document.getElementById("hidden_video")
    await run_process(video, width, jitter, res, "main_canvas", fps, current_seed)
    
    # Force redraw of lens
    window.updateLensDimensions()

async def run_process(video_elem, width, jitter, target_height, canvas_id, target_fps, seed):
    canvas = document.getElementById("hidden_canvas")
    ctx = canvas.getContext("2d")
    out_canvas = document.getElementById(canvas_id)
    out_ctx = out_canvas.getContext("2d")
    
    scale = 1.0
    if target_height > 0 and video_elem.videoHeight > target_height:
        scale = target_height / video_elem.videoHeight
    
    w = int(video_elem.videoWidth * scale)
    h = int(video_elem.videoHeight * scale)
    canvas.width = w; canvas.height = h
    
    curr_slit = max(1, int(width * scale))
    curr_jitter = int(jitter * scale)

    duration = video_elem.duration
    step = 1 / target_fps
    
    total_frames = max(1, int(duration * target_fps))
    
    out_canvas.width = total_frames * curr_slit
    out_canvas.height = h
    
    current_time = 0.0
    x_pos = 0
    random.seed(seed)
    
    while current_time < duration:
        video_elem.currentTime = current_time
        await asyncio.sleep(0.02)
        try: ctx.drawImage(video_elem, 0, 0, w, h)
        except: break
        
        offset = random.randint(-curr_jitter, curr_jitter)
        center_x = (w // 2) + offset
        start_x = max(0, min(w - curr_slit, center_x))
        
        try: out_ctx.drawImage(canvas, start_x, 0, curr_slit, h, x_pos, 0, curr_slit, h)
        except: break
        
        current_time += step
        x_pos += curr_slit
        
        if x_pos % 200 == 0: await asyncio.sleep(0.001)

    </script>
</body>
</html>
